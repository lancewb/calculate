# Android Kotlin 纸牌游戏开发提示词

**角色设定：**
你是一位精通 Kotlin、Jetpack Compose 和 Material Design 3 (MD3) 的资深 Android 开发工程师。请协助我构建一款名为“巫师的标签 (Wizard's Tags)”的单机安卓纸牌游戏。

**技术栈要求：**
* **语言:** Kotlin
* **UI 框架:** Jetpack Compose (Material Design 3)
* **架构:** MVVM (Model-View-ViewModel) + 单向数据流 (UDF)
* **状态管理:** StateFlow / ViewModel

---

## 第一部分：游戏核心规则 (Source of Truth)

请严格基于以下规则设计逻辑，不要随意更改：

1.  **游戏配置：**
    * **人数:** 4人 或 5人。
    * **总轮数:** 4人局为4轮，5人局为5轮。
    * **牌库:** 红、黄、橙、绿、紫 5种颜色，每色 1-15 号，共75张牌。
    * **手牌数:** 4人局每人12张，5人局每人15张。
    * **标签系统 (资源):** 红、黄、橙、绿、紫（对应牌色，-2分/个），彩色（万能，-3分/个），黑色（惩罚，-4分/个）。

2.  **角色与流程：**
    * **龙头 (Dealer):** 第一轮随机指定，后续每轮顺时针轮换。
    * **发牌:** 每一轮重新洗牌并分发。
    * **领标签 (Bidding Phase):**
        * 按顺时针顺序（龙头开始），玩家查看手牌后，根据策略领取若干个标签（红/黄/橙/绿/紫/彩）,每人可以看到场上所有人领取标签的情况，但看不到其他人的手牌。
        * **黑巫师 (Role):** 玩家可以选择“不领标签”，身份变为“黑巫师”。黑巫师每轮仅限一人，遵循**“先选先得”**原则。如果前序玩家已选黑巫师，后续玩家不可再选。
        * **初始分:** 普通玩家 = 所选标签总分；黑巫师 = 0分。

3.  **出牌规则 (Play Phase) - 重点逻辑:**
    * 龙头先出牌。
    * **跟牌机制 (Follow Suit):** 后续玩家必须出与“头牌（第一张牌）”颜色相同的牌。
        * *强制限制:* 程序必须检测玩家手牌。如果手中有同色牌，**必须**打出同色牌（UI上应禁用其他颜色牌的点击）；如果手中无同色牌，则可以打出任意颜色的牌。
        * *超时处理:* 如果是玩家超时（或机器人），若有同色牌必须随机出一张同色牌，否则随机出一张任意牌。
    * 红牌为**常驻王牌 (Trump)**。

4.  **赢家判定 (Winning Logic):**
    * 一轮出牌（Trick）结束后判定赢家：
        * **情况A（有红牌）:** 场上所有红牌中数字最大者获胜（无论头牌是什么颜色）。
        * **情况B（无红牌）:** 场上与“头牌颜色”相同的牌中，数字最大者获胜。
    * 赢家获得下一轮的优先出牌权。

5.  **丢弃标签与惩罚 (Discard & Penalty):**
    * 赢家必须根据规则丢弃（抵消）自己手中的一个标签：
        * **若红牌获胜 且 头牌不是红色:** 可丢弃 [头牌颜色标签] 或 [红标签] 或 [彩标签]。
        * **若红牌获胜 且 头牌是红色:** 只能丢弃 [红标签] 或 [彩标签]。
        * **若非红牌获胜:** 只能丢弃 [获胜牌颜色标签] 或 [彩标签]。
    * **惩罚:** 如果赢家手中没有符合上述条件的标签可丢，则强制获得一个**黑色标签**（本轮不可丢弃）。
    * **黑巫师加分:** 一旦场上有人获得黑色标签，黑巫师玩家的本轮额外加分自动 +1。

6.  **结算:**
    * 手牌出完为一轮结束。
    * 单轮得分 = (剩余标签总分) + (黑巫师额外加分)。
    * X轮结束后，总分最高者获胜。

---

## 第二部分：代码实现任务拆解

请分步骤为我生成代码，不要一次性输出所有内容。

### Step 1: 数据模型 (Data Models)
请定义以下 Kotlin Data Classes 和 Enums：
* `CardColor`, `TagType` (包含分数定义).
* `Card` (包含 `isRed()` 辅助方法).
* `Player` (包含手牌、当前标签、分数、身份状态).
* `GameState` (包含当前轮数、当前出牌堆、当前行动玩家索引、黑巫师是谁等).
* **重点:** 请设计一个 `CardValidator` 单例或工具类，包含 `getPlayableCards(hand: List<Card>, leadCard: Card?): List<Card>` 方法，用于严格执行跟牌逻辑。

### Step 2: 游戏引擎逻辑 (Game Engine)
请实现 `GameViewModel` 或 `GameEngine` 中的核心函数：
* `claimRole(playerIndex, tags, wantsToBeBlackWizard)`: 处理领标签逻辑。需包含检查：如果黑巫师已被占用，则抛出异常或返回失败。
* `playCard(playerIndex, card)`: 执行出牌，需调用 Validator 验证合法性，并自动触发下一位或结算。
* `evaluateTrickWinner(trickCards)`: 根据规则4判断赢家。
* `processTrickResult(winnerIndex, leadCard, winningCard)`: 执行规则5（自动丢标签或发黑标签，并更新黑巫师加分）。

### Step 3: AI 机器人逻辑 (Bot Strategy)
请实现一个 `BotAI` 类，包含简单、中等、困难三种策略。
* **接口:** `decideTagSelection(...)` 和 `decideCardToPlay(...)`。
* **规则遵守:** 机器人的出牌必须调用 Step 1 中的 `CardValidator`，确保不会犯规（即有黄必出黄）。
* **困难模式策略:**
    * **选标签:** 根据手牌颜色分布按比例选取。
    * **出牌:** 尽量赢下自己能丢标签的局；如果是黑巫师，故意输掉（出小牌）或迫使别人无法丢标签（即迫使别人赢下他们没有标签颜色的局）。

### Step 4: UI 构建 (Jetpack Compose)
使用 MD3 风格构建界面：
* **GameTableScreen:**
    * 中央显示出牌区。
    * 四周显示其他玩家（头像、剩余牌数、**当前拥有的标签墙**）。
    * 底部显示玩家手牌（需高亮可行牌，变灰/禁用不可行牌，以符合跟牌规则）。
* **BiddingDialog:**
    * 每轮开始时的弹窗。
    * 显示标签选择器。
    * 包含“成为黑巫师”选项，但如果 `GameState.blackWizardId` 已经不为空，则该选项需显示为“已被抢占”且不可点击。

---